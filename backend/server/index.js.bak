// server/index.js
require('dotenv').config();

const express = require('express');
const cors = require('cors');
const db = require('./db'); // your db.js that returns getConnection()
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
// Enable CORS and explicitly allow Authorization header for preflight requests
app.use(cors({
  origin: true,
  methods: ['GET','POST','PUT','DELETE','OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json());

const PORT = process.env.PORT || 4000;
const JWT_SECRET = process.env.JWT_SECRET || 'change_this_secret';

// ----- Health check -----
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok' });
});

// ----- Auth: login -----
// Expects JSON { email, password }
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body || {};
  if (!email || !password) return res.status(400).json({ error: 'missing email or password' });

  try {
    const conn = await db.getConnection();
    const [rows] = await conn.query('SELECT id, email, name, password_hash, role FROM users WHERE email = ?', [email]);
    conn.release();

    if (!rows[0]) return res.status(401).json({ error: 'Invalid credentials' });

    const user = rows[0];
    const match = await bcrypt.compare(password, user.password_hash);
    if (!match) return res.status(401).json({ error: 'Invalid credentials' });

    const token = jwt.sign({ id: user.id, email: user.email, role: user.role, name: user.name }, JWT_SECRET, { expiresIn: '8h' });

    res.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });
  } catch (err) {
    console.error('Login error:', err);
    res.status(500).json({ error: 'server error' });
  }
});

// ----- Middleware: protect routes -----
function authMiddleware(req, res, next) {
  const header = req.headers.authorization;
  // log presence of auth header for debugging (do not print token)
  console.log('auth header present:', !!header);
  if (!header) return res.status(401).json({ error: 'missing authorization header' });
  const parts = header.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return res.status(401).json({ error: 'invalid authorization format' });
  const token = parts[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch (e) {
    return res.status(401).json({ error: 'invalid or expired token' });
  }
}

// ----- Debug endpoint: check if browser sends Authorization header -----
app.get('/api/debug-headers', (req, res) => {
  const header = req.headers.authorization || null;
  const masked = header ? (typeof header === 'string' ? (header.slice(0, 20) + '...') : true) : null;
  res.json({ hasAuthorization: !!header, maskedAuthorization: masked });
});

// Ensure quotations table exists (extended schema to store items + salesperson)
async function ensureQuotationsTable() {
  const conn = await db.getConnection();
  try {
    await conn.query(`
      CREATE TABLE IF NOT EXISTS quotations (
        id INT AUTO_INCREMENT PRIMARY KEY,
        quotation_no VARCHAR(255) UNIQUE,
        customer_id INT,
        customer_name VARCHAR(255),
        salesperson_id INT,
        quotation_date DATE,
        validity_days INT DEFAULT 30,
        items JSON,
        terms TEXT,
        notes TEXT,
        total_value DECIMAL(18,2) DEFAULT 0,
        status VARCHAR(50) DEFAULT 'draft',
        approved_by VARCHAR(255) DEFAULT NULL,
        approved_at DATETIME DEFAULT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=INNODB;
    `);
  } finally {
    conn.release();
  }
}

// ----- Stats endpoint (uses DB) -----
app.get('/api/stats', async (req, res) => {
  try {
    const conn = await db.getConnection();
    const [rows] = await conn.query('SELECT COUNT(*) as total FROM quotations');
    conn.release();
    const total = (rows && rows[0] && rows[0].total) ? rows[0].total : 0;
    res.json({ totalQuotations: total });
  } catch (err) {
    console.error('Error fetching stats:', err);
    res.status(500).json({ error: 'db error' });
  }
});

// ----- Recent quotations (for dashboard) -----
// Return parsed items (array) + salesperson_name + productNames
app.get('/api/quotations/recent', async (req, res) => {
  try {
    await ensureQuotationsTable();
    const conn = await db.getConnection();
    const [rows] = await conn.query(`
      SELECT q.id, q.quotation_no, q.customer_name, q.items, q.total_value, q.status, q.created_at,
             q.salesperson_id, u.name as salesperson_name
      FROM quotations q
      LEFT JOIN users u ON u.id = q.salesperson_id
      ORDER BY q.created_at DESC
      LIMIT 10
    `);
    conn.release();

    const parsed = (rows || []).map(r => {
      try { if (typeof r.items === 'string') r.items = JSON.parse(r.items); } catch(e){}
      const productNames = Array.isArray(r.items) ? r.items.map(it => it.name || it.product_name || '').filter(Boolean) : [];
      return {
        ...r,
        productNames,
        salesperson_name: r.salesperson_name || null
      };
    });

    res.json(parsed);
  } catch (err) {
    console.error('Error fetching recent quotations:', err);
    res.status(500).json({ error: 'db error' });
  }
});

// ----- Get all quotations (full page) -----
// Return parsed items + salesperson_name
app.get('/api/quotations', async (req, res) => {
  try {
    await ensureQuotationsTable();
    const conn = await db.getConnection();
    const [rows] = await conn.query(`
      SELECT q.*, u.name as salesperson_name
      FROM quotations q
      LEFT JOIN users u ON u.id = q.salesperson_id
      ORDER BY q.created_at DESC
    `);
    conn.release();
    const out = (rows || []).map(r => {
      try { if (typeof r.items === 'string') r.items = JSON.parse(r.items); } catch(e){}
      return r;
    });
    res.json(out || []);
  } catch (err) {
    console.error('Error fetching quotations:', err);
    res.status(500).json({ error: 'db error' });
  }
});

// ----- Create a new quotation (protected) -----
// Accepts JSON payload with many fields (items array, salesperson_id, etc.)
app.post('/api/quotations', authMiddleware, async (req, res) => {
  // Log a masked preview for debugging authorization/body issues
  try { console.log('POST /api/quotations called by user:', req.user ? { id: req.user.id, email: req.user.email } : null); } catch(e){}
  const {
    quotation_no,
    customer_id,
    customer_name,
    salesperson_id,
    quotation_date,
    validity_days,
    total_value,
    items,
    terms,
    notes,
    status
  } = req.body || {};

  try { console.log('quotation payload preview:', { quotation_no: quotation_no ? quotation_no.slice(0,20) : null, customer_name, total_value, salesperson_id }); } catch(e){}

  if (!quotation_no || !customer_name) {
    return res.status(400).json({ error: 'quotation_no and customer_name are required' });
  }

  try {
    await ensureQuotationsTable();
    const conn = await db.getConnection();
    const itemsJson = items ? JSON.stringify(items) : null;
    const qdate = quotation_date ? quotation_date : null;

    const [result] = await conn.query(
      `INSERT INTO quotations
        (quotation_no, customer_id, customer_name, salesperson_id, quotation_date, validity_days, items, terms, notes, total_value, status)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        quotation_no,
        customer_id || null,
        customer_name || '',
        salesperson_id || null,
        qdate,
        validity_days || 30,
        itemsJson,
        terms || null,
        notes || null,
        total_value || 0,
        (status || 'draft').toLowerCase()
      ]
    );
    conn.release();
    res.status(201).json({ id: result.insertId, quotation_no });
  } catch (err) {
    console.error('Error creating quotation:', err);
    res.status(500).json({ error: 'db error' });
  }
});

// Quotation by id (public)
app.get('/api/quotations/:id', async (req, res) => {
  try {
    await ensureQuotationsTable();
    const id = req.params.id;
    const conn = await db.getConnection();
    const [rows] = await conn.query(`
      SELECT q.*, u.name as salesperson_name
      FROM quotations q
      LEFT JOIN users u ON u.id = q.salesperson_id
      WHERE q.id = ?
      LIMIT 1
    `, [id]);
    conn.release();
    if (!rows || rows.length === 0) return res.status(404).json({ error: 'not found' });
    // if items is JSON string, try to parse (driver differences)
    const q = rows[0];
    try { if (typeof q.items === 'string') q.items = JSON.parse(q.items); } catch(e){}
    res.json({ quotation: q });
  } catch (err) {
    console.error('Error fetching quotation:', err);
    res.status(500).json({ error: 'db error' });
  }
});

// Update quotation (PUT) - protected
app.put('/api/quotations/:id', authMiddleware, async (req, res) => {
  const id = req.params.id;
  const { customer_name, quotation_date, validity_days, items, terms, notes, total_value, status, salesperson_id } = req.body || {};
  try {
    await ensureQuotationsTable();
    const conn = await db.getConnection();
    const itemsJson = items ? JSON.stringify(items) : null;
    const [r] = await conn.query(
      `UPDATE quotations SET customer_name = ?, quotation_date = ?, validity_days = ?, items = ?, terms = ?, notes = ?, total_value = ?, status = ?, salesperson_id = ? WHERE id = ?`,
      [customer_name, quotation_date || null, validity_days || 30, itemsJson, terms || null, notes || null, total_value || 0, status || 'draft', salesperson_id || null, id]
    );
    conn.release();
    res.json({ success: true, affectedRows: r.affectedRows });
  } catch (err) {
    console.error('update quotation error', err);
    res.status(500).json({ error: 'db error' });
  }
});

// Approve a quotation (protected) - only admin/manager allowed
app.put('/api/quotations/:id/approve', authMiddleware, async (req, res) => {
  try {
    // role-check: adjust roles as used in your users table
    const role = req.user && req.user.role;
    if (!role || !['admin', 'manager'].includes(role)) {
      return res.status(403).json({ error: 'forbidden: insufficient role' });
    }

    const id = req.params.id;
    const approver = req.user && (req.user.name || req.user.email) ? (req.user.name || req.user.email) : (req.body.approver || 'system');

    await ensureQuotationsTable();
    const conn = await db.getConnection();

    // only approve if not already approved
    const [existingRows] = await conn.query('SELECT status FROM quotations WHERE id = ?', [id]);
    if (!existingRows || existingRows.length === 0) {
      conn.release();
      return res.status(404).json({ error: 'quotation not found' });
    }
    const currentStatus = existingRows[0].status;
    if (currentStatus && currentStatus.toLowerCase() === 'approved') {
      conn.release();
      return res.status(400).json({ error: 'already approved' });
    }

    const [r] = await conn.query(
      `UPDATE quotations SET status = 'approved', approved_by = ?, approved_at = NOW() WHERE id = ?`,
      [approver, id]
    );

    // fetch updated row to return to client
    const [rows] = await conn.query('SELECT * FROM quotations WHERE id = ?', [id]);
    conn.release();

    const updated = rows && rows[0] ? rows[0] : null;
    try { if (updated && typeof updated.items === 'string') updated.items = JSON.parse(updated.items); } catch(e){}

    res.json({ success: true, quotation: updated });
  } catch (err) {
    console.error('Error approving quotation:', err);
    res.status(500).json({ error: 'db error' });
  }
});

// Optionally: a route to get the current user info (protected)
app.get('/api/me', authMiddleware, async (req, res) => {
  // req.user is from token payload
  res.json({ user: req.user });
});

// --- customers endpoints ---
app.get('/api/customers', async (req, res) => {
  try {
    const conn = await db.getConnection();
    await conn.query(`
      CREATE TABLE IF NOT EXISTS customers (
        id INT AUTO_INCREMENT PRIMARY KEY,
        company_name VARCHAR(255),
        contact_person VARCHAR(255),
        phone VARCHAR(50),
        email VARCHAR(255),
        gstin VARCHAR(50),
        address TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=INNODB;
    `);
    const [rows] = await conn.query('SELECT * FROM customers ORDER BY created_at DESC');
    conn.release();
    res.json(rows);
  } catch (err) {
    console.error('customers error', err);
    res.status(500).json({ error: 'db error' });
  }
});

app.post('/api/customers', async (req, res) => {
  const { company_name, contact_person, phone, email, gstin, address } = req.body || {};
  if (!company_name) return res.status(400).json({ error: 'company_name required' });
  try {
    const conn = await db.getConnection();
    const [resu] = await conn.query(
      'INSERT INTO customers (company_name, contact_person, phone, email, gstin, address) VALUES (?, ?, ?, ?, ?, ?)',
      [company_name, contact_person, phone, email, gstin, address]
    );
    conn.release();
    res.status(201).json({ id: resu.insertId });
  } catch (err) {
    console.error('create customer error', err);
    res.status(500).json({ error: 'db error' });
  }
});

// --- products endpoints ---
app.get('/api/products', async (req, res) => {
  try {
    const conn = await db.getConnection();
    await conn.query(`
      CREATE TABLE IF NOT EXISTS products (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255),
        hsn_code VARCHAR(50),
        uom VARCHAR(30),
        unit_price DECIMAL(12,2),
        tax_rate DECIMAL(5,2),
        status VARCHAR(20) DEFAULT 'active',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=INNODB;
    `);
    const [rows] = await conn.query('SELECT * FROM products ORDER BY created_at DESC');
    conn.release();
    res.json(rows);
  } catch (err) {
    console.error('products error', err);
    res.status(500).json({ error: 'db error' });
  }
});

app.post('/api/products', async (req, res) => {
  const { name, hsn_code, uom, unit_price, tax_rate, status } = req.body || {};
  if (!name) return res.status(400).json({ error: 'name required' });
  try {
    const conn = await db.getConnection();
    const [r] = await conn.query(
      'INSERT INTO products (name, hsn_code, uom, unit_price, tax_rate, status) VALUES (?, ?, ?, ?, ?, ?)',
      [name, hsn_code || '', uom || 'NOS', unit_price || 0, tax_rate || 0, status || 'active']
    );
    conn.release();
    res.status(201).json({ id: r.insertId });
  } catch (err) {
    console.error('create product error', err);
    res.status(500).json({ error: 'db error' });
  }
});

// Update a product
app.put('/api/products/:id', async (req, res) => {
  const { id } = req.params;
  const { name, hsn_code, uom, unit_price, tax_rate, status } = req.body || {};
  if (!name) return res.status(400).json({ error: 'name required' });
  try {
    const conn = await db.getConnection();
    const [r] = await conn.query(
      'UPDATE products SET name = ?, hsn_code = ?, uom = ?, unit_price = ?, tax_rate = ?, status = ? WHERE id = ?',
      [name, hsn_code || '', uom || 'NOS', unit_price || 0, tax_rate || 0, status || 'active', id]
    );
    conn.release();
    res.json({ affectedRows: r.affectedRows });
  } catch (err) {
    console.error('update product error', err);
    res.status(500).json({ error: 'db error' });
  }
});

// Delete a product
app.delete('/api/products/:id', async (req, res) => {
  const { id } = req.params;
  try {
    const conn = await db.getConnection();
    const [r] = await conn.query('DELETE FROM products WHERE id = ?', [id]);
    conn.release();
    res.json({ affectedRows: r.affectedRows });
  } catch (err) {
    console.error('delete product error', err);
    res.status(500).json({ error: 'db error' });
  }
});





// Start server
app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
});
